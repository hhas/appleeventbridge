#!/usr/bin/python
# -*- coding: utf-8 -*-

""" aebglue -- Generate Swift and Objective-C application glues for AppleEventBridge """

# TO DO: what, if any, standard Swift method/var names need reserved?

# TO DO: use separate escaping for specifiers vs parameters (the latter only need to escape keywords, not reserved method names)

# TO DO: how practical is it for specifiers to be pure Swift classes, rather than subclasses of NSObject? (this'd reduce the no. of method names that need reserved)

# TO DO: use correct signatures for appdata.terminologyWithError_, AEBDynamicSDEFParser.copyScriptingDefinitionAtURL_error_ so error description is returned; see objc.setSignatureForSelector()

# TO DO: XXXSymbol.m shouldn't include type and enum symbols already defined by AEBStaticSymbol (also check how partial matches, e.g. where name is same but code is different, are treated)

# TO DO: SDEF exporter needs to support synonyms

# TO DO: how to format type attributes in SDEF exporter? (currently both built-in and app-defined type names use AS format) (note that `type` attributes are somewhat ambiguous, since they may be either name or [enumeration-only?] code) 

# TO DO: -o option should be directory in which glue folder will be created; glue folder's name should be autogenerated ('XXXGlue'); optionally prompt user before overwriting existing folder (add -f option to force overwrite)

# TO DO: obtain reserved NSObject, AEB method names dynamically

import getopt, os, re, shutil, string, sys
import xml.etree.ElementTree as ET

import objc # (this script uses system Python, which includes PyObjC as standard)
from Foundation import NSObject, NSBundle, NSURL


######################################################################
# IMPORT AEB FRAMEWORK
######################################################################

# TO DO: how best to locate AppleEventBridge.framework? (used to obtain app terminology)

kFrameworkName = 'AppleEventBridge'

# find framework relative to self (this requires aebglue script to be inside AppleEventBridge.framework)
mpath = re.match('(.+/%s.framework)' % kFrameworkName, os.path.abspath(os.path.expanduser(__file__)))
if not mpath:
    print >> sys.stderr, 'aebglue executable must be inside %s.framework bundle.' % kFrameworkName
    sys.exit(1)
kAEBBundle = objc.loadBundle(kFrameworkName, globals(), bundle_path=mpath.group(1))

kFrameworkVersion =  kAEBBundle.infoDictionary()['CFBundleShortVersionString']


######################################################################
# UTILITIES
######################################################################


def writefile(path, s):
    with open(path, 'w') as f:
        f.write(s.encode('utf-8'))

def readfile(path):
    with open(path) as f:
            return f.read().decode('utf-8')

def readtemplate(name):
    path = kAEBBundle.pathForResource_ofType_inDirectory_(name, 'txt', u'templates')
    if not path:
        raise ValueError("Can't find template: %s" % name)
    return readfile(path)


######################################################################
# KEYWORD CONVERTER
######################################################################
#
# Important: the following must be reserved so that terminology-defined properties and methods don't conflict
# with existing superclass properties and methods:
#
# - names of language keywords
# - names of NSObject class and instance methods
# - names of methods used in AEBStaticSymbol, AEBStaticSpecifier classes
# - names of additional methods used in Application classes
# - names of built-in keyword arguments in AEBStaticCommand
#
# Notes:
#
# - ObjC superclass methods that take two or more arguments do not need to be reserved
#
# - The following tokens are reserved as punctuation in Swift and can’t be used as custom operators: 
#         (, ), {, }, [, ], ., ,, :, ;, =, @, #, & (as a prefix operator), ->, `, ?, and ! (as a postfix operator).
#

kSwiftKeywords = { # Swift 2.0
    # Keywords used in declarations: 
    "class", "deinit", "enum", "extension", "func", "import", "init", "internal", "let", "operator", 
    "private", "protocol", "public", "static", "struct", "subscript", "typealias", "var",
    # Keywords used in statements: 
    "break", "case", "continue", "default", "do", "else", "fallthrough", "for", "if", "in", "return", 
    "switch", "where", "while",
    # Keywords used in expressions and types: 
    "as", "dynamicType", "false", "is", "nil", "self", "Self", "super", "true", 
    "__COLUMN__", "__FILE__", "__FUNCTION__", "__LINE__",
    # Keywords reserved in particular contexts: 
    "associativity", "convenience", "dynamic", "didSet", "final", "infix", "inout", "lazy", "left", 
    "mutating", "none", "nonmutating", 
    "optional", "override", "postfix", "precedence", "prefix", "Protocol", "required", "right", 
    "Type", "unowned", "weak", "willSet",
    # "get", "set",  # only used in defining getters/setters so shouldn't conflict with apps' get(), set() commands
}

kObjectiveCKeywords = {
    "const",
    "extern",
    "auto",
    "register",
    "static",
    "unsigned",
    "signed",
    "volatile",
    "char",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "typedef",
    "struct",
    "union",
    "enum",
    "id",
    "Class",
    "SEL",
    "IMP",
    "BOOL",
    "return",
    "goto",
    "if",
    "else",
    "case",
    "default",
    "switch",
    "break",
    "continue",
    "while",
    "do",
    "for",
    "in",
    "sizeof",
    "self",
    "super",
    "nil",
    "NIL",
    "YES",
    "NO",
    "true",
    "false",
    "inline",
}

kNSObjectMethods = { # TO DO: introspect NSObject for these, if practical
    "initialize",
    "load",
    "new",
    "alloc",
    "allocWithZone",
    "init",
    "copy",
    "copyWithZone",
    "mutableCopy",
    "mutableCopyWithZone",
    "dealloc",
    "finalize",
    "class",
    "superclass",
    "isSubclassOfClass",
    "instancesRespondToSelector",
    "conformsToProtocol",
    "methodForSelector",
    "instanceMethodForSelector",
    "instanceMethodSignatureForSelector",
    "methodSignatureForSelector",
    "description",
    "poseAsClass",
    "cancelPreviousPerformRequestsWithTarget",
    "forwardInvocation",
    "doesNotRecognizeSelector",
    "awakeAfterUsingCoder",
    "classForArchiver",
    "classForCoder",
    "classForKeyedArchiver",
    "classFallbacksForKeyedArchiver",
    "classForKeyedUnarchiver",
    "classForPortCoder",
    "replacementObjectForArchiver",
    "replacementObjectForCoder",
    "replacementObjectForKeyedArchiver",
    "replacementObjectForPortCoder",
    "setVersion",
    "version",
    "attributeKeys",
    "classDescription",
    "inverseForRelationshipKey",
    "toManyRelationshipKeys",
    "toOneRelationshipKeys",
    "classCode",
    "className",
    "scriptingProperties",
    "setScriptingProperties",
}


kAEBSpecifierMethods = { # names reserved on both Swift and ObjC glues
    "app",
    "con",
    "its",
    # miscellaneous
    "isRunning",
    "relaunchMode",
    "seRelaunchMode",
    "launchApplication",
    "launchApplicationWithError",
    "reconnectApplication",
    "reconnectApplicationWithError",
    "beginTransaction",
    "beginTransactionWithError",
    "beginTransactionWithSession",
    "abortTransaction",
    "abortTransactionWithError",
    "endTransaction",
    "endTransactionWithError",
}

kAEBSwiftSpecifierMethods = {
    # custom property/element specifiers
    "propertyByCode",
    "elementsByCode",
    "customRoot",
    # element(s) selectors
    "ID",
    "beginning",
    "end",
    "before",
    "after",
    "previous",
    "next",
    "first",
    "middle",
    "last",
    "any",
    # test clause constructors
    "beginsWith",
    "endsWith",
    "contains",
    "isIn",
    # used by AEBSymbol
    "symbolWithName",
    "symbolWithCode",
    # currently unused
    "help", # TO DO: uppercase?
}

kAEBSwiftParameterNames = {
    "directParameter",
    "eventAttributes", # TO DO: this will probably change to individual arg names
}


kAEBObjectiveCMethods = {
    # custom property/element specifiers
    "propertyByCode",
    "elementsByCode",
    "customRoot",
    # element(s) selectors
    "at",
    "byIndex",
    "byName",
    "byID",
    # (-at:to:, -byRange:to: have multiple args so don't need escaped as they can't conflict)
    "byTest",
    "beginning",
    "end",
    "before",
    "after",
    "previous",
    "next",
    "first",
    "middle",
    "last",
    "any",
    # test clause constructors
    "greaterThan",
    "greaterOrEquals",
    "equals",
    "notEquals",
    "lessThan",
    "lessOrEquals",
    "beginsWith",
    "endsWith",
    "contains",
    "isIn",
    "doesNotBeginWith",
    "doesNotEndWith",
    "doesNotContain",
    "isNotIn",
    "AND",
    "NOT",
    "OR",
    # shortcuts
    "setItem",
    "getItem",
    "getItemWithError",
    "getList",
    "getListWithError",
    "getItemOfType",
    "getListOfType",
    "getIntWithError",
    "getLongWithError",
    "getDoubleWithError",
    # used by aebglue-generated XXApplication classes
    "initWithName",
    "initWithBundleID",
    "initWithSignature",
    "initWithPath",
    "initWithURL",
    "initWithProcessID",
    "initWithDescriptor",
    # used by AEBStaticSymbol
    "symbolWithName",
    "symbolWithCode",
    # used by AEBStaticCommand
    "considering",
    "sendMode",
    "waitForReply",
    "ignoreReply",
    "queueReply",
    "timeout",
    "requestedClass",
    "requestedType",
    "returnClass",
    "returnType",
    "returnList",
    "returnListOfClass",
    "returnListOfType",
    "returnDescriptor",
    "sendWithError",
    "send",
    # currently unused
    "ignoring",
    "returnID",
    "help",
}


#######


class SwiftKeywordConverter(AEBKeywordConverter):
    
    _legalchars = string.ascii_letters + '_' # TO DO: extend this as per Swift identifier rules? or do users prefer sticking to C-style? (e.g. for ObjC interop)
    _alphanum = _legalchars + string.digits
    _reservedspecifierwords = kSwiftKeywords | kAEBSwiftSpecifierMethods | kAEBSpecifierMethods | kNSObjectMethods
    _reservedparameterwords = kSwiftKeywords | kAEBSwiftParameterNames
    
    def init(self):
        self = super(AEBKeywordConverter, self).init()
        if self:
            self._cache = {}
        return self
    
    def convertName_reservedKeywords_(self, s, reservedwords):
        """Convert string to identifier.
            s : str
            Result : str
        """
        if s not in self._cache:
            s = s.strip()
            if s.startswith('init '): # if "init" is first word in name, escape it separately
                s = 'init_ ' + s[5:]
            legal = self._legalchars
            res = ''
            uppercasenext = False
            for c in s:
                if c in legal:
                    if uppercasenext:
                        c = c.upper()
                        uppercasenext = False
                    res += c
                elif c in ' -/':
                    uppercasenext = True
                elif c == '&':
                    res += 'And'
                else:
                    if res == '':
                        res = '_' # avoid creating an invalid identifier
                    res += '0x%2.2X' % ord(c) # TO DO: revise this; use Swift identifier quoting rather than character replacement where possible
                legal = self._alphanum
            if (res in reservedwords or res.startswith('_') or res[:3] in {'AEM', 'aem', 'AEB', 'aeb'} or not res): # TO DO: backtick reserved swift keywords? or will that cause more confusion than it solves?
                res = self.escapeName_(res)
            self._cache[s] = str(res)
        return self._cache[s]
            
    def convertSpecifierName_(self, s):
        return self.convertName_reservedKeywords_(s, self._reservedspecifierwords)

    def convertParameterName_(self, s):
        return self.convertName_reservedKeywords_(s, self._reservedparameterwords)

    def escapeName_(self, s):
        return s + '_'


#######


class ObjCKeywordConverter(AEBKeywordConverter):
    
    _legalchars = string.ascii_letters + '_'
    _alphanum = _legalchars + string.digits
    _reservedwords = kObjectiveCKeywords | kAEBObjectiveCMethods | kAEBSpecifierMethods | kNSObjectMethods
    
    def init(self):
        self = super(AEBKeywordConverter, self).init()
        if self:
            self._cache = {}
        return self
    
    def convertSpecifierName_(self, s):
        """Convert string to identifier.
            s : str
            Result : str
        """
        if s not in self._cache:
            legal = self._legalchars
            res = ''
            uppercasenext = False
            for c in s.strip():
                if c in legal:
                    if uppercasenext:
                        c = c.upper()
                        uppercasenext = False
                    res += c
                elif c in ' -/':
                    uppercasenext = True
                elif c == '&':
                    res += 'And'
                else:
                    if res == '':
                        res = '_' # avoid creating an invalid identifier
                    res += '0x%2.2X' % ord(c)
                legal = self._alphanum
            if (res in self._reservedwords or res.startswith('_') or res[:3] in {'AEM', 'aem', 'AEB', 'aeb'} or not res):
                res = self.escapeName_(res)
            self._cache[s] = str(res)
        return self._cache[s]

    convertParameterName_ = convertSpecifierName_
    
    def escapeName_(self, s):
        return s + '_'


######################################################################
# DEFAULT PREFIX GENERATOR
######################################################################


kReservedPrefixes = {'NS', 'AEM', 'AEB', 'APP', 'CON', 'ITS'} # glues cannot use these prefixes


def makeprefix(name, minlen=3): # TO DO: need to test this with various typical app names
    """ Auto-generate a reasonable default classname prefix from an application name.
        
        Notes:
        
        - Only A-Z/a-z characters are used, so is most effective when app's name is mostly composed of those characters.
        
        - Raises ValueError if name doesn't contain enough suitable characters to construct minimum-length prefix.
        """
    words = u''.join(re.findall(u'([A-Za-z ])', name)).split()
    if len(words) >= minlen: # use first letter of each word
        acronym = u''.join(word[0].upper() for word in words)
        if acronym not in kReservedPrefixes:
            return acronym
    words = [word[0].upper()+word[1:] for word in words]
    caps = re.sub(u'[^A-Z]', '', u''.join(words)) # include any other uppercase letters
    if len(caps) >= minlen and caps not in kReservedPrefixes:
        return caps
    phoneticwords = re.sub(u'([A-Z]|[a-z]\\b|[b-df-hj-np-tv-z ])', '\\1', ''.join(words)).split() # eliminate lowercase vowels, except at end of word
    i = len(phoneticwords)
    short = minlen - len(caps) # how many more characters are needed?
    while i and short: # start uppercasing last character of each word, working backwards
        i -= 1
        word = phoneticwords[i]
        if re.search(u'[a-z]$', word):
            phoneticwords[i] = word[:-1]+word[-1].upper()
            short -= 1
    if not short:
        phonetic = re.sub(u'[a-z]', '', u''.join(phoneticwords))
        if phonetic not in kReservedPrefixes:
            return phonetic
    all = u''.join(words).upper().replace(' ', '') # starting to run short of options, so reinclude lowercase vowels
    if len(all) == minlen:
        if all in kReservedPrefixes:
            raise ValueError('Auto-generated prefix conflicts with reserved prefix: %r' % all)
        return all
    elif len(all) > minlen:
        prefixlen = 2
        for _ in range(minlen):
            for i in range(len(words)):
                word = words[i]
                words[i] = word[:prefixlen].upper() + word[prefixlen:]
                caps = re.sub(u'[^A-Z]', '', u''.join(words)) # use first letter of each word plus other uppercase letters (acronym-like)
                if len(caps) >= minlen and caps not in kReservedPrefixes:
                    return caps
            prefixlen += 1
    raise ValueError('Not enough characters to construct a %i-character prefix.' % minlen)


######################################################################
# SDEF EXPORTER
######################################################################

# TO DO: make sure app terms that conflict with builtins are escaped correctly



def exportsdef(appurl, outpath, keywordconverter, prefix, commandnamesuffix):
    """ Export application's .sdef file as user documentation. Keywords are reformatted as appropriate. 
    
        outpath : str -- glue path with .sdef prefix
    """
    def convertnode(node, attrname, suffix='', prefix=''):
        attr = node.get(attrname)
        if attr: node.set(attrname, prefix+keywordconverter.convertSpecifierName_(attr)+suffix)
    sdef = AEBDynamicSDEFParser.copyScriptingDefinitionAtURL_error_(appurl, None)
    if not sdef:
        raise ValueError("Can't export SDEF for %r: %s" % (appurl,  "can't get terminology."))
    root = ET.XML(str(sdef))
    symbolnamespace = '%s.' % prefix
    for suite in root.findall('./suite'):
        for key in ['command', 'event']:
            for command in suite.findall(key):
                convertnode(command, 'name', '' if command.find('direct-parameter') is None else commandnamesuffix)
                for param in command.findall('parameter'):
                    attr = param.get('name')
                    if attr: param.set('name', keywordconverter.convertSpecifierName_(attr)+':')
        for key in ['class', 'class-extension', 'record-type']:
            for klass in suite.findall(key):
                convertnode(klass, 'name')
                # optional plural names require extra fiddling
                pluralname = klass.get('plural')
                if not pluralname:
                    pluralname = klass.get('name')
                    if pluralname:
                        pluralname += 's'
                if pluralname:
                    klass.set('plural', pluralname)
                for elem in klass.findall('element'):
                    convertnode(elem, 'type')
                for prop in klass.findall('property'):
                    convertnode(prop, 'name')
                cont = klass.find('contents')
                if cont is not None and cont.get('name'):
                    convertnode(cont, 'name')
                for resp in klass.findall('responds-to'):
                    convertnode(resp, 'name')
                    convertnode(resp, 'command')
        for enumeration in suite.findall('enumeration'):
            for enum in enumeration.findall('enumerator'):
                convertnode(enum, 'name', prefix=symbolnamespace)
        for value in suite.findall('value-type'):
            convertnode(value, 'name')
    ET.ElementTree(root).write(outpath, encoding="utf-8", xml_declaration=True)


######################################################################
# GLUE RENDERER
######################################################################


def insert(tpl, label, content): # replace all tags with given name
    return tpl.replace(u'«{}»'.format(label), content)

def repeat(tpl, label, contentlist, renderer): # find and render all NEW...END blocks with given name (note: identically named blocks can contain same or different placeholder content, but all will be rendered with same data and renderer callback)
    # caution: names within inner repeat blocks must be different to names in outer repeat blocks
    # caution: when replacing multiple blocks with the same label, contentlist must be a list, not a generator (otherwise only the first block will render)
    def insertblock(m):
        subtpl = m.group(1).rstrip()
        return u''.join(renderer(subtpl, content) for content in contentlist)
    return re.sub(u'(?s)\\n?«\\+%s»(.*?)«-%s»' % (label, label), insertblock, tpl)


def fcc(code): # format OSType as hex int
    return u'0x%08x' % code

def insertcodeandname(tpl, content):
    (code, name) = content
    tpl = insert(tpl, 'NAME', name)
    return insert(tpl, 'CODE', fcc(code))

def insertcommand(tpl, term):
    params = sorted((p.code(), p.name()) for p in term.parameters())
    tpl = insert(tpl, 'COMMAND_NAME', term.name())
    tpl = insert(tpl, 'CAP_NAME', term.name()[0].upper()+term.name()[1:])
    tpl = insert(tpl, 'EVENT_CLASS', fcc(term.eventClass()))
    tpl = insert(tpl, 'EVENT_ID', fcc(term.eventID()))
    return repeat(tpl, 'PARAMETER', params, insertcodeandname)


kElement = 1
kProperty = 3
kCommand = 4

kType = 0x74797065
kEnum = 0x656e756d

def renderglue(tpl, gluedir, gluesourcefilename, appinfo, appvar, terms):
    """
        tpl : str -- template
        gluedir : str -- path to directory into which this file will be written
        gluesourcefilename : str -- the name of the file to be written
        appinfo : AppInfo -- general information, if any, on application
        appvar : str | None -- Swift/ObjC-style identifier; used as convenience constructor for Application object
        terms : AEBDynamicTerminology
    """
    # insert general info
    tpl = insert(tpl, 'PREFIX', appinfo.prefix)
    tpl = insert(tpl, 'GLUE_NAME', gluesourcefilename)
    tpl = insert(tpl, 'FRAMEWORK_NAME', kFrameworkName+'.framework')
    tpl = insert(tpl, 'FRAMEWORK_VERSION', kFrameworkVersion)
    tpl = insert(tpl, 'APP_VAR_NAME', appvar or 'UNKNOWN') # TO DO: delete this var from glue if appvar is None
    # include application info, if relevant
    tpl = insert(tpl, 'APP_NAME', appinfo.filename or 'UNKNOWN')
    tpl = insert(tpl, 'APP_VERSION', appinfo.version or 'UNKNOWN')
    tpl = insert(tpl, 'BUNDLE_ID', appinfo.bundleid or 'UNKNOWN') # TO DO: delete/disable relevant code
    # insert name-code mappings
    # [(str, AEBDynamicTerm),...]
    specifierbyname = sorted(terms.specifiersByName().items(), key=lambda o: o[0]) # selectors, raw constants
    # [((code: int, name: str), desctype: int),...]
    typebyname = sorted((((desc.typeCodeValue(), name), desc.descriptorType()) 
            for name, desc in terms.typesByName().items()), key=lambda o: o[0][1]) # symbol contructors, raw constants
    # [(code: int, name: str),...]
    typebycode = sorted(terms.typesByCode().items(), key=lambda o: o[1]) # symbol lookup
    propertybycode = sorted(terms.propertiesByCode().items(), key=lambda o: o[1])
    elementbycode = sorted(terms.elementsByCode().items(), key=lambda o: o[1])
    for label, contentlist in [
            ('PROPERTY_FORMATTER', propertybycode),
            ('ELEMENTS_FORMATTER', elementbycode),
            ('SYMBOL_SWITCH', typebycode),
            ('TYPE_SYMBOL', (v for v, desctype in typebyname if desctype == kType)),
            ('ENUM_SYMBOL', (v for v, desctype in typebyname if desctype == kEnum)),
            ('PROPERTY_SPECIFIER', ((t.code(), t.name()) for name, t in specifierbyname if t.kind() == kProperty)),
            ('ELEMENTS_SPECIFIER', ((t.code(), t.name()) for name, t in specifierbyname if t.kind() == kElement))]:
        tpl = repeat(tpl, label, contentlist, insertcodeandname)
    tpl = repeat(tpl, 'COMMAND', [t for name, t in specifierbyname if t.kind() == kCommand], insertcommand)
    writefile(os.path.join(gluedir, gluesourcefilename), tpl)


######################################################################
# MAKE GLUE
######################################################################

# TO DO: also need to generate constants file[s] (Q. what about AEBSwiftSymbol? should that also be autogenerated each time? if so, need to check how best to get and process AS's terminology)


class AppInfo:
    def __init__(self, appurl=None, prefix=None, appvar=None):
        self.appurl, self._appvar = appurl, appvar
        if appurl:
            appbundle = NSBundle.bundleWithURL_(appurl)
            if not appbundle:
                raise ValueError(u'Not a valid bundle: %s' % appurl)
            appinfo = dict(appbundle.infoDictionary() if appbundle else {})
            self.filename = appurl.lastPathComponent()
            self.name = appinfo.get('CFBundleName')
            self.version = appinfo.get('CFBundleShortVersionString')
            self.bundleid = appinfo.get('CFBundleIdentifier')
            self.prefix = prefix or makeprefix(self.name or 'UNKNOWN')
        else:
            self.filename = 'N/A'
            self.name, self.version, self.bundleid, self.prefix = 'Default', 'N/A', 'UNKNOWN', prefix or 'AEB'
        self.gluename = self.prefix + 'Glue'
    
    def appvar(self, keywordconverter):
        name = keywordconverter.convertSpecifierName_(self._appvar or self.name or 'UNKNOWN')
        if name == self.prefix:
            raise ValueError("-n IDENTIFIER and -p PREFIX options cannot be the same: %s" % name)
        return name
    
    def terminology(self, keywordconverter, usesdef=False):
        appdata = AEBDynamicAppData.alloc().initWithApplicationURL_useSDEF_keywordConverter_(
            self.appurl, usesdef, keywordconverter)
        terms = appdata.terminologyWithError_(None)
        if not terms:
            raise ValueError("Can't get terminology for: %s" % appurl)
        return terms


def makeswiftglue(gluedir, appinfo, usesdef):
    keywordconverter = SwiftKeywordConverter.alloc().init()
    terms = appinfo.terminology(keywordconverter, usesdef)
    appvar = appinfo.appvar(keywordconverter)
    renderglue(readtemplate('SwiftGlueTemplate'), gluedir, appinfo.gluename+'.swift', appinfo, appvar, terms)
    if appinfo.appurl:
        exportsdef(appinfo.appurl, os.path.join(gluedir, appinfo.gluename+'-swift.sdef'), keywordconverter, appinfo.prefix, '')


def makeobjcglue(gluedir, appinfo, usesdef):
    keywordconverter = ObjCKeywordConverter.alloc().init()
    terms = appinfo.terminology(keywordconverter, usesdef)
    appvar = appinfo.appvar(keywordconverter)
    for templatename, suffix in [('ObjCInterfaceGlueTemplate', '.h'), ('ObjCImplementationGlueTemplate', '.m')]:
        renderglue(readtemplate(templatename), gluedir, appinfo.gluename+suffix, appinfo, appvar, terms)
    if appinfo.appurl:
        exportsdef(appinfo.appurl, os.path.join(gluedir, appinfo.gluename+'-objc.sdef'), keywordconverter, appinfo.prefix, ':')


######################################################################
# MAIN
######################################################################


if __name__ == '__main__':
    try:
        import time; tt = time.time() # DEBUG
        opts, args = getopt.getopt(sys.argv[1:], 'dhn:op:rsv') # TO DO: language option (default=swift)
        opts = dict(opts)
        if not args or '-h' in opts:
            print >> sys.stderr, "Generate Swift/Objective-C application glues for AppleEventBridge."
            print >> sys.stderr
            print >> sys.stderr, "Usage:"
            print >> sys.stderr
            print >> sys.stderr, "    aebglue [-h] [-n VAR-NAME] [-o] [-p PREFIX] [-r] [-s] APP-NAME [OUT-DIR]"
            print >> sys.stderr, "    aebglue -d [OUT-DIR]"
            print >> sys.stderr
            print >> sys.stderr, "APP-PATH - Name or path to application."
            print >> sys.stderr
            print >> sys.stderr, "OUT-DIR - Path to directory in which the glue directory will be created;"
            print >> sys.stderr, "          if omitted, the current working directory is used."
            print >> sys.stderr
            print >> sys.stderr, "On completion, the path to the newly created glue is written to STDOUT."
            print >> sys.stderr
            print >> sys.stderr, "Options:"
            print >> sys.stderr
            print >> sys.stderr, "    -d           Generate glue using default terminology only"
            print >> sys.stderr, "    -h           Show this help and exit"
            print >> sys.stderr, "    -n VAR-NAME  Application's name as a C-style identifier;"
            print >> sys.stderr, "                   if omitted, a default name is auto-generated"
            print >> sys.stderr, "    -o           By default, a Swift glue is generated; use -o"
            print >> sys.stderr, "                   to generate an Objective-C glue instead"
            print >> sys.stderr, "    -p PREFIX    Class names prefix; if omitted, a default "
            print >> sys.stderr, "                   3-character prefix is auto-generated"
            print >> sys.stderr, "    -r           If glue directory already exists, replace it"
            print >> sys.stderr, "                   instead of raising 'path exists' error"
            print >> sys.stderr, "    -s           Use SDEF terminology instead of AETE, e.g. if"
            print >> sys.stderr, "                   application's ascr/gdte handler is broken"
            print >> sys.stderr, "    -v           Output AppleEventBridge.framework version and exit"
            print >> sys.stderr
            print >> sys.stderr, "Examples:"
            print >> sys.stderr
            print >> sys.stderr, "    aebglue TextEdit"
            print >> sys.stderr
            print >> sys.stderr, "    aebglue -o iTunes"
            print >> sys.stderr
            print >> sys.stderr, "    aebglue -p TE TextEdit ~/Documents"
            print >> sys.stderr
            sys.exit()
        if '-v' in opts:
            print >> sys.stdout, kFrameworkVersion
            sys.exit()
        if '-d' in opts: # use default terms only
            appurl = None
            if len(args) == 0:
                outdir = os.getcwd()
            elif len(args) == 1:
                outdir = args[-1]
            else:
                raise ValueError('Wrong number of arguments.')
        else: # use terms from specified application, plus default terms
            if len(args) == 1:
                outdir = os.getcwd()
            elif len(args) == 2:
                outdir = args[-1]
            else:
                raise ValueError('Wrong number of arguments.')
            appname = args[0]
            if appname.startswith('~/'):
                appname = os.path.expanduser(appname)
            appurl = AEMApplication.fileURLForApplicationWithName_(appname)
            if not appurl:
                raise ValueError("Can't find application: %s" % appname)
        appinfo = AppInfo() if '-d' in opts else AppInfo(appurl, opts.get('-p'), opts.get('-n'))
        if not appinfo.bundleid:
            print >> sys.stderr, "Warning: default constructor won't work as bundle identifier not found."
        # create new XXGlue directory
        outdir = os.path.abspath(os.path.expanduser(outdir))
        if not os.path.isdir(outdir):
            raise ValueError("Not a valid output directory: %s" % outdir)
        gluedir = os.path.join(outdir, appinfo.gluename)
        if os.path.exists(gluedir):
            if '-r' in opts and os.path.isdir(gluedir):
                shutil.rmtree(gluedir)
            else:
                raise ValueError("Can't create %s as path already exists: %s" % (appinfo.gluename, gluedir))
        os.mkdir(gluedir)
        # generate glue files
        (makeobjcglue if '-o' in opts else makeswiftglue)(gluedir, appinfo, '-s' in opts)
        print >> sys.stderr, "Created %s (%ims)" % (appinfo.gluename, (time.time()-tt)*1000) # DEBUG
        print >> sys.stdout, gluedir
    except Exception, e:
        print >> sys.stderr, "Error:", e
        import traceback; traceback.print_exc() # DEBUG
        sys.exit(1)




