#!/usr/bin/python

""" aebglue -- Generate Objective-C application glues for AppleEventBridge """

# TO DO: use correct signatures for appdata.terminologyWithError_, AEBDynamicSDEFParser.copyScriptingDefinitionAtURL_error_ so error description is returned; see objc.setSignatureForSelector()

# TO DO: XXXSymbol.m shouldn't include type and enum symbols already defined by AEBSymbol (also check how partial matches, e.g. where name is same but code is different, are treated)

# TO DO: SDEF exporter needs to support synonyms

# TO DO: how to format type attributes in SDEF exporter? (currently both built-in and app-defined type names use AS format) (note that `type` attributes are somewhat ambiguous, since they may be either name or [enumeration-only?] code) 

# TO DO: [optionally?] define macro shortcuts for symbols? (e.g. TETypeDocument, TETypeWord, TEEnumYes/eTEEnumNo/TEEnumAsk, TEPropName) or is it best to minimize namespace pollution and require users to write TESymbol.document, TESymbol.yes, TESymbol.name, etc.

# TO DO: make -p option optional

# TO DO: -o option should be directory in which glue folder will be created; glue folder's name should be autogenerated ('XXXGlue'); optionally prompt user before overwriting existing folder (add -f option to force overwrite)

# TO DO: obtain reserved NSObject, AEB method names dynamically

import codecs, getopt, os, re, string, StringIO, sys
import xml.etree.ElementTree as ET

import objc # (this script uses system Python, which includes PyObjC as standard)
from Foundation import NSObject, NSBundle


kReservedPrefixes = {'NS', 'AEM', 'AEB'} # glues cannot use these prefixes


######################################################################
# IMPORT AEB FRAMEWORK
######################################################################

# note: aebglue script must be inside AppleEventBridge.framework as it finds framework relative to itself
kFrameworkName = 'AppleEventBridge'
mpath = re.match('(.+/%s.framework)' % kFrameworkName, os.path.abspath(os.path.expanduser(__file__)))
if not mpath:
    print >> sys.stderr, 'aebglue executable must be inside %s.framework bundle.' % kFrameworkName
    sys.exit(1)
bundle = objc.loadBundle(kFrameworkName, globals(), bundle_path=mpath.group(1))
kGlueVersion =  bundle.infoDictionary()['CFBundleShortVersionString']


######################################################################
# KEYWORD CONVERTER
######################################################################

# Important: the following must be reserved:
#
# - names of ObjC keywords
# - names of NSObject class and instance methods
# - names of methods used in AEBSymbol, AEBSpecifier classes
# - names of additional methods used in Application classes
# - names of built-in keyword arguments in AEBStaticCommand


kObjectiveCKeywords = [
    "const",
    "extern",
    "auto",
    "register",
    "static",
    "unsigned",
    "signed",
    "volatile",
    "char",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "typedef",
    "struct",
    "union",
    "enum",
    "id",
    "Class",
    "SEL",
    "IMP",
    "BOOL",
    "return",
    "goto",
    "if",
    "else",
    "case",
    "default",
    "switch",
    "break",
    "continue",
    "while",
    "do",
    "for",
    "in",
    "sizeof",
    "self",
    "super",
    "nil",
    "NIL",
    "YES",
    "NO",
    "true",
    "false",
    "inline",
]

kNSObjectMethods = [
    "initialize",
    "load",
    "new",
    "alloc",
    "allocWithZone",
    "init",
    "copy",
    "copyWithZone",
    "mutableCopy",
    "mutableCopyWithZone",
    "dealloc",
    "finalize",
    "class",
    "superclass",
    "isSubclassOfClass",
    "instancesRespondToSelector",
    "conformsToProtocol",
    "methodForSelector",
    "instanceMethodForSelector",
    "instanceMethodSignatureForSelector",
    "methodSignatureForSelector",
    "description",
    "poseAsClass",
    "cancelPreviousPerformRequestsWithTarget",
    "forwardInvocation",
    "doesNotRecognizeSelector",
    "awakeAfterUsingCoder",
    "classForArchiver",
    "classForCoder",
    "classForKeyedArchiver",
    "classFallbacksForKeyedArchiver",
    "classForKeyedUnarchiver",
    "classForPortCoder",
    "replacementObjectForArchiver",
    "replacementObjectForCoder",
    "replacementObjectForKeyedArchiver",
    "replacementObjectForPortCoder",
    "setVersion",
    "version",
    "attributeKeys",
    "classDescription",
    "inverseForRelationshipKey",
    "toManyRelationshipKeys",
    "toOneRelationshipKeys",
    "classCode",
    "className",
    "scriptingProperties",
    "setScriptingProperties",
]


kAppleEventBridgeMethods = [
    # used by AEBSpecifier
    "ID",
    "beginning",
    "end",
    "before",
    "after",
    "previous",
    "next",
    "first",
    "middle",
    "last",
    "any",
    "beginsWith",
    "endsWith",
    "contains",
    "isIn",
    "doesNotBeginWith",
    "doesNotEndWith",
    "doesNotContain",
    "isNotIn",
    "AND",
    "NOT",
    "OR",
    
    # miscellaneous
    "isRunning",
    "launchApplication",
    "launchApplicationWithError",
    "reconnectApplication",
    "reconnectApplicationWithError",
    
    # shortcuts
    "setItem",
    "getItem",
    "getItemWithError",
    "getList",
    "getListWithError",
    "getItemOfType",
    "getListOfType",
    "getIntWithError",
    "getLongWithError",
    "getDoubleWithError",
    
    # used by aebglue-generated XXApplication classes
    "initWithName",
    "initWithBundleID",
    "initWithSignature",
    "initWithPath",
    "initWithURL",
    "initWithProcessID",
    "initWithDescriptor",
    "beginTransaction",
    "beginTransactionWithSession",
    "abortTransaction",
    "endTransaction",
    "beginTransactionWithError",
    "endTransactionWithError",
    "abortTransactionWithError",
    "specifierWithObject",
    
    # used by AEBSymbol
    "symbolWithName",
    "symbolWithCode",
    
    # used by AEBStaticCommand
    "considering",
    "sendMode",
    "waitForReply",
    "ignoreReply",
    "queueReply",
    "timeout",
    "requestedClass",
    "requestedType",
    "returnClass",
    "returnType",
    "returnList",
    "returnListOfClass",
    "returnListOfType",
    "returnDescriptor",
    "sendWithError",
    "send",
    
    # currently unused
    "ignoring",
    "returnID",
    "help",
]


class KeywordConverter(NSObject):
    
    _legalchars = string.ascii_letters + '_'
    _alphanum = _legalchars + string.digits
    _reservedwords = set(kObjectiveCKeywords + kNSObjectMethods + kAppleEventBridgeMethods)
    
    def init(self):
        self = super(KeywordConverter, self).init()
        if self:
            self._cache = {}
        return self
    
    def convert_(self, s):
        """Convert string to identifier.
            s : str
            Result : str
        """
        if s not in self._cache:
            legal = self._legalchars
            res = ''
            uppercasenext = False
            for c in s.strip():
                if c in legal:
                    if uppercasenext:
                        c = c.upper()
                        uppercasenext = False
                    res += c
                elif c in ' -/':
                    uppercasenext = True
                elif c == '&':
                    res += 'And'
                else:
                    if res == '':
                        res = '_' # avoid creating an invalid identifier
                    res += '0x%2.2X' % ord(c)
                legal = self._alphanum
            if (res in self._reservedwords or res.startswith('_') or res.startswith('AEM') 
                    or res.startswith('AEB') or not res):
                res = self.escape_(res)
            self._cache[s] = str(res)
        return self._cache[s]
        
    def escape_(self, s):
        return s + '_'


kKeywordConverter = KeywordConverter.alloc().init()


######################################################################
# GLUE RENDERER
######################################################################


class ImplementationRenderer:
    """ Generates .m files and corresponding .h files. """
    
    kPrefixTag = '<PREFIX>'
    kAutoReleaseStartTag = '<AUTOSTART>'
    kAutoReleaseEndTag = '<AUTOEND>'
    
    
    def __init__(self, appname, prefix, outdir, noarc):
        if prefix in kReservedPrefixes:
            raise ValueError("Can't use reserved prefix: %r" % prefix)
        self._appname = appname
        self._outdir = outdir
        self._prefix = prefix
        self._autoreleasestart = '[' if noarc else ''
        self._autoreleaseend = ' autorelease]' if noarc else ''
        if not os.path.exists(outdir):
            os.mkdir(outdir)

    def newglue(self, name, hasimplementation=True):
        path = os.path.join(self._outdir, self._prefix + name)
        self._interface = open(path + '.h', 'w')
        if hasimplementation:
            self._implementation = open(path + '.m', 'w')
        else:
            self._implementation = StringIO.StringIO()
        # headers
        for fn, f, suffix in [(self.writeh, self._interface, 'h'), (self.writem, self._implementation, 'm')]:
            fn('//')
            fn('// <PREFIX>%s.%s' % (name, suffix))
            print >> f, '// ' + self._appname
            fn('// %s %s' % (kFrameworkName, kGlueVersion))
            fn('//')
            fn('')
        self.writeh('#import <Foundation/Foundation.h>')
        self.writeh('#import "AppleEventBridge/AppleEventBridge.h"')
        self.writem('#import "<PREFIX>%s.h"' % name)
    
    def writeh(self, src):
        print >> self._interface, src.replace(self.kPrefixTag, self._prefix)
    
    def writem(self, src):
        print >> self._implementation, (src.replace(self.kPrefixTag, self._prefix)
                .replace(self.kAutoReleaseStartTag, self._autoreleasestart)
                .replace(self.kAutoReleaseEndTag, self._autoreleaseend))
    
    def importmacro(self, name):
        self.writeh('#import "%s"' % name)
    
    def definemacro(self, name, value):
        self.writeh('#define %s (%s)' % (name, value))
    
    def newclass(self, name, parent):
        self.writeh('\n@interface %s : %s' % (name, parent))
        self.writem('\n@implementation %s' % name)
    
    def endclass(self):
        self.writeh('@end\n')
        self.writem('@end\n')
    
    def newmethod(self, src): # use when defining new methods
        self.writeh(src + ';')
        self.writem(src + ' {')
    
    def submethod(self, src): # use when overriding existing methods
        self.writem(src + ' {')
        
    def endmethod(self):
        self.writem('}')
    
    def comment(self, txt):
        src = '\n/* %s */\n' % txt
        self.writeh(src)
        self.writem(src)
    
    def __iadd__(self, value):
        self.writem(value)
        return self
    
    def endglue(self):
        self._interface.close()
        self._implementation.close()


##


kElement = 1
kProperty = 3
kCommand = 4

kType = 0x74797065
kEnum = 0x656e756d


class ClassBuilder:
        
    kLegalCodeChars = re.compile('^[a-zA-Z0-9* ]+$')
    
    def __init__(self, terms, bundleid, noarc):
        self._bundleid, self._noarc = bundleid, noarc
        # [(str, NSAppleEventDescriptor),...]
        self.typebyname = sorted(terms.typesByName().items(), key=lambda o: o[0])
        # [(str, AEBDynamicTerm),...]
        self.specifierbyname = sorted(terms.specifiersByName().items(), key=lambda o: (o[1].kind(), o[0]))
        # [(int, str),...]
        self.typebycode = sorted(terms.typesByCode().items(), key=lambda o: o[1])
        self.propertybycode = sorted(terms.propertiesByCode().items(), key=lambda o: o[1])  
        self.elementbycode = sorted(terms.elementsByCode().items(), key=lambda o: o[1])
    
    ##
    
    def _formatcode(self, code):
        """ Format OSTypes as literals """
        code = '%08x' % code
        codestr = codecs.decode(code, 'hex_codec')
        return "'%s'" % codestr if self.kLegalCodeChars.match(codestr) else '0x%s' % code
    
    
    def _capname(self, s):
        """ Uppercase first character of identifier """
        return s and s[0].upper() + s[1:] or '_'

    ##
    
    def render_symbol(self, src):
        src.newglue('SymbolGlue')
        src.newclass('<PREFIX>Symbol', 'AEBSymbol')
        # AE code to symbol converter
        src.submethod('+ (instancetype)symbolWithCode:(OSType)code_')
        src += '    switch (code_) {'
        for code, name in self.typebycode:
            src += '        case %s: return self.%s;' % (self._formatcode(code), name)
        src += '        default: return [super symbolWithCode: code_];'
        src += '    }'
        src.endmethod()
        # symbol constructors
        prevkind = const = None
        for name, desc in sorted(self.typebyname, key=lambda o: o[1].descriptorType()):
            kind = desc.descriptorType()
            if prevkind != kind:
                label, const = {kType:('Types and properties','typeType'), kEnum:('Enumerators','typeEnumerated')}[kind]
                src.comment(label)
            prevkind = kind
            src.newmethod('+ (instancetype)%s' % name)
            src += '    AEB_RETURN_SYMBOL(@"%s", %s, %s);' % (name, const, self._formatcode(desc.typeCodeValue()))
            src.endmethod()
        src.endclass()
    
    ##

    def render_commands(self, src):
        src.newglue('CommandGlue')
        src.importmacro('<PREFIX>FormatterGlue.h')
        # add -description support
        src.newclass('<PREFIX>Command', 'AEBStaticCommand')
        src.submethod('- (NSString *)AEBFormatObject:(id)obj appData:(id)appData')
        src += '    return [<PREFIX>Formatter formatObject: obj appData: appData];'
        src.endmethod()
        src.endclass()
        # render each command class
        for name, term in self.specifierbyname:
            if term.kind() == kCommand:
                params = sorted((p.name(), p.code()) for p in term.parameters())
                src.newclass('<PREFIX>' + self._capname(name) + 'Command', '<PREFIX>Command')
                for paramname, paramcode in params:
                    src.newmethod('- (instancetype)%s:(id)value' % (paramname))
                    src += '    [self setParameter: value forKeyword: %s];' % self._formatcode(paramcode)
                    src += '    return self;'
                    src.endmethod()
                src.submethod('- (NSString *)AEBCommandName')
                src += '    return @"%s";' % name
                src.endmethod()
                if params:
                    src.submethod('- (NSString *)AEBParameterNameForCode:(DescType)code')
                    src += '    switch (code) {'
                    for paramname, paramcode in params:
                        src += '        case %s: return @"%s";' % (self._formatcode(paramcode), paramname)
                    src += '    }'
                    src += '    return [super AEBParameterNameForCode: code];'
                    src += '}'
                src.endclass()

    ##
    
    def render_specifier(self, src):
        src.newglue('SpecifierGlue')
        src.importmacro('<PREFIX>CommandGlue.h')
        src.importmacro('<PREFIX>FormatterGlue.h')
        for name in ['App', 'Con', 'Its']:
            src.definemacro('<PREFIX>%s' % name, '[<PREFIX>Specifier specifierWithAppData: nil aemQuery: AEM%s]' % name)
        src.newclass('<PREFIX>Specifier', 'AEBSpecifier')
        # add -description support
        src.submethod('- (NSString *)description')
        src += '    return [<PREFIX>Formatter formatObject: aemQuery appData: appData];'
        src.endmethod()
        # add dictionary-defined property, element and command methods
        prevkind = None
        for name, term in self.specifierbyname:
            kind = term.kind()
            if kind != prevkind:
                src.comment({kCommand: 'Commands', kProperty: 'Properties', kElement: 'Elements'}[kind])
            prevkind = kind
            if kind == kCommand:
                classname = '<PREFIX>' + self._capname(name) + 'Command'
                for directParam in ['', ':(id)directParameter']:
                    src.newmethod('- (%s *)%s%s' % (classname, name, directParam))
                    src += '    return [%s commandWithAppData: appData' % classname
                    src += '                       eventClass: %s' % self._formatcode(term.eventClass())
                    src += '                          eventID: %s' % self._formatcode(term.eventID())
                    src += '                  directParameter: %s' % (
                            'directParameter' if directParam else '(__bridge id)kAEBNoDirectParameter')
                    src += '                      parentQuery: aemQuery];'
                    src.endmethod()
            else:
                src.newmethod('- (instancetype)%s' % name)
                src += '    return [self.class specifierWithAppData: appData'
                src += '                                   aemQuery: [(AEMObjectSpecifier *)aemQuery %s: %s]];' % (
                        {kProperty: 'property', kElement: 'elements'}[kind], self._formatcode(term.code()))
                src.endmethod()
        src.endclass()

    ##
    
    def render_application(self, src):
        src.newglue('ApplicationGlue')
        src.importmacro('<PREFIX>SymbolGlue.h')
        src.importmacro('<PREFIX>SpecifierGlue.h')
        src.newclass('<PREFIX>Application', '<PREFIX>Specifier')
        # private initialiser
        src.comment('note: clients shouldn\'t need to call -initWithTargetType:data: themselves')
        src.newmethod('- (instancetype)initWithTargetType:(AEBTargetType)targetType_ data:(id)targetData_')
        src += '    AEBStaticAppData *data = [[AEBStaticAppData alloc] initWithApplicationClass: AEMApplication.class'
        src += '                                                                    symbolClass: <PREFIX>Symbol.class'
        src += '                                                                 specifierClass: <PREFIX>Specifier.class'
        src += '                                                                     targetType: targetType_'
        src += '                                                                     targetData: targetData_];'
        src += '    self = [super initWithAppData: data aemQuery: AEMApp];'
        if self._noarc:
            src += '    [data release];'
        src += ''
        src += '    if (!self) return self;'
        src += '    return self;'
        src.endmethod()
        # public constructors
        src.comment('initialisers')
        src.newmethod('+ (instancetype)application')
        src += '    return <AUTOSTART>[[self alloc] init]<AUTOEND>;'
        src.endmethod()
        src.newmethod('+ (instancetype)currentApplication')
        src += '    return <AUTOSTART>[[self alloc] initCurrentApplication]<AUTOEND>;'
        src.endmethod()
        for name, call in [
                ('+ (instancetype)applicationWithName:(NSString *)name', 'initWithName: name'),
                ('+ (instancetype)applicationWithURL:(NSURL *)url', 'initWithURL: url'),
                ('+ (instancetype)applicationWithBundleID:(NSString *)bundleID', 'initWithBundleID: bundleID'),
                ('+ (instancetype)applicationWithProcessID:(pid_t)pid', 'initWithProcessID: pid'),
                ('+ (instancetype)applicationWithDescriptor:(NSAppleEventDescriptor *)desc', 'initWithDescriptor: desc')]:
            src.newmethod(name)
            src += '    return <AUTOSTART>[[self alloc] %s]<AUTOEND>;' % call
            src.endmethod()
        src.newmethod('- (instancetype)init')
        if self._bundleid:
            src += ('    return [self initWithBundleID: @"%s"];' % self._bundleid.replace('\\', '\\\\').replace('"', '\\"'))
        else:
            src += '    return nil;'
        src.endmethod()
        src.newmethod('- (instancetype)initCurrentApplication')
        src += '    return [self initWithTargetType: kAEBTargetCurrent data: nil];'
        src.endmethod()
        for name, target, data in [
                ('- (instancetype)initWithName:(NSString *)name', 'kAEBTargetName', 'name'),
                ('- (instancetype)initWithURL:(NSURL *)url', 'kAEBTargetURL', 'url'),
                ('- (instancetype)initWithBundleID:(NSString *)bundleID', 'kAEBTargetBundleID', 'bundleID'),
                ('- (instancetype)initWithProcessID:(pid_t)pid', 'kAEBTargetProcessID', '[NSNumber numberWithInteger: pid]'),
                ('- (instancetype)initWithDescriptor:(NSAppleEventDescriptor *)desc', 'kAEBTargetDescriptor', 'desc')]:
            src.newmethod(name)
            src += '    return [self initWithTargetType: %s data: %s];' % (target, data)
            src.endmethod()
        src.comment('misc')
        src.newmethod('- (<PREFIX>Specifier *)specifierWithObject:(id)object')
        src += '    if ([object isKindOfClass: <PREFIX>Specifier.class]) {'
        src += '        return <AUTOSTART>[[<PREFIX>Specifier alloc] initWithAppData: appData aemQuery: [object AEMQuery]]<AUTOEND>;'
        src += '    } else if ([object isKindOfClass: AEMQuery.class]) {'
        src += '        return <AUTOSTART>[[<PREFIX>Specifier alloc] initWithAppData: appData aemQuery: object]<AUTOEND>;'
        src += '    } else if (!object) {'
        src += '        return <AUTOSTART>[[<PREFIX>Specifier alloc] initWithAppData: appData aemQuery: AEMApp]<AUTOEND>;'
        src += '    } else {'
        src += '        return <AUTOSTART>[[<PREFIX>Specifier alloc] initWithAppData: appData aemQuery: AEMRoot(object)]<AUTOEND>;'
        src += '    }'
        src.endmethod()
        src.endclass()
    
    ##
    
    def render_specifierrenderer(self, src):
        src.newglue('FormatterGlue')
        src.newclass('<PREFIX>Formatter', 'AEBStaticFormatter')
        for methodname, items in [('property', self.propertybycode), ('element', self.elementbycode)]:
            src.submethod('- (NSString *)%sByCode:(OSType)code' % methodname)
            src += '    switch (code) {'
            for code, name in items:
                src += '        case %s: return @"%s";' % (self._formatcode(code), name)
            src += '        default: return nil;'
            src += '    }'
            src.endmethod()
        src.submethod('- (NSString *)prefix')
        src += '    return @"<PREFIX>";'
        src.endmethod()
        src.endclass()
    
    ##
    
    def _renderaemconstant(self, type, name, code, src):
        src.writeh('    %s<PREFIX>%s = %s,' % (type, self._capname(name), self._formatcode(code)))
    
    def render_aemheader(self, src):
        src.newglue('RawCodes', False)
        src.comment('Types, enumerators, properties')
        src.writeh('enum {')
        for name, desc in self.typebyname:
            self._renderaemconstant('k', name, desc.typeCodeValue(), src)
        src.writeh('};\n')
        src.writeh('enum {')
        for name, term in self.specifierbyname:
            if term.kind() != kCommand:
                self._renderaemconstant('p' if term.kind() == kProperty else 'e', name, term.code(), src)
        src.writeh('};\n')
        src.comment('Events')
        knownparams = set()
        for name, term in self.specifierbyname:
            if term.kind() == kCommand:
                src.writeh('enum {')
                self._renderaemconstant('ec', name, term.eventClass(), src)
                self._renderaemconstant('ei', name, term.eventID(), src)
                params = sorted((p.name(), p.code()) for p in term.parameters())
                for name, code in params:
                    if name in knownparams:
                        src.writeh('//  %s<PREFIX>%s = %s,' % ('ep', 
                                self._capname(name), self._formatcode(code)))
                    else:
                        knownparams.add(name)
                        self._renderaemconstant('ep', name, code, src)
                src.writeh('};\n')
    
    ##
    
    def render_header(self, src):
        src.newglue('Glue', False)
        src.importmacro('<PREFIX>ApplicationGlue.h')
        src.importmacro('<PREFIX>CommandGlue.h')
        src.importmacro('<PREFIX>SymbolGlue.h')
        src.importmacro('<PREFIX>SpecifierGlue.h')
        src.importmacro('<PREFIX>FormatterGlue.h')
    
    
    #######
    # public
    
    def render(self, src):
        self.render_symbol(src)
        self.render_commands(src)
        self.render_specifier(src)
        self.render_application(src)
        self.render_specifierrenderer(src)
        self.render_aemheader(src)
        self.render_header(src)


######################################################################
# SDEF EXPORTER
######################################################################


def _convertnode(node, attrname, suffix='', prefix=''):
    attr = node.get(attrname)
    if attr:
        node.set(attrname, prefix+kKeywordConverter.convert_(attr)+suffix)


def exportsdef(sdef, prefix, outpath):
    root = ET.XML(sdef)
    for suite in root.findall('./suite'):
        for key in ['command', 'event']:
            for command in suite.findall(key):
                _convertnode(command, 'name', '' if command.find('direct-parameter') is None else ':')
                for param in command.findall('parameter'):
                    _convertnode(param, 'name', ':')
        for key in ['class', 'class-extension', 'record-type']:
            for klass in suite.findall(key):
                _convertnode(klass, 'name')
                # optional plural names require extra fiddling
                pluralname = klass.get('plural')
                if not pluralname:
                    pluralname = klass.get('name')
                    if pluralname:
                        pluralname += 's'
                if pluralname:
                    klass.set('plural', pluralname)
                for elem in klass.findall('element'):
                    _convertnode(elem, 'type')
                for prop in klass.findall('property'):
                    _convertnode(prop, 'name')
                cont = klass.find('contents')
                if cont is not None and cont.get('name'):
                    _convertnode(cont, 'name')
                for resp in klass.findall('responds-to'):
                    _convertnode(resp, 'name')
                    _convertnode(resp, 'command')
        for enumeration in suite.findall('enumeration'):
            for enum in enumeration.findall('enumerator'):
                _convertnode(enum, 'name', prefix=prefix+'Symbol.')
        for value in suite.findall('value-type'):
            _convertnode(value, 'name')
    ET.ElementTree(root).write(outpath, encoding="utf-8", xml_declaration=True)


######################################################################
# PUBLIC
######################################################################


def nametoprefix(name): # TO DO: currently unused; update to use 3-char prefixes, and call if -p option is omitted
    """ Used to generate default ObjC classname prefixes based on application names.
        
        Notes:
        
        - Only characters A-Z and a-z are used.
        - If name contains two or more words, first character of first and second words are used.
        - If name contains one word, first character is used and second character is either
            first uppercase character found in rest of word, or first consonant found in rest 
            of word, or second character in word.
        
        - If unable to construct prefix by above rules for any reason, entire name is converted
            to standard ObjC identifier and first character is uppercased.
    """
    try:
        words = ''.join(re.findall('([A-Za-z ])', name)).split()
        if len(words) > 1:
            word1, word2 = words[:2]
            return (word1[0] + word2[0]).upper()
        else:
            word = words[0]
            upper = re.findall('[A-Z]', word[1:])
            if upper:
                char = upper[0]
            else:
                char = re.findall('[^AEIOUaeiou]', word[1:])[0]
            return (word[0] + char).upper()
    except:
        prefix = kKeywordConverter.convert_(name)
        return prefix[0].upper() + prefix[1:]


##


def makeappglue(appname, prefix, outdir, noarc, usesdef):
    """
        appname : str -- application name or path
        prefix : str -- ObjC classname prefix, e.g. 'TE'
        outdir : str -- path to glue folder
        noarc : bool -- if True, use explicit release/autorelease instead of ARC
        usesdef : bool -- if True, get application's terminology as SDEF instead of AETE
    """
    url = AEMApplication.fileURLForApplicationWithName_(appname)
    if not url:
        raise ValueError("Can't make glue for %r: %s" % (appname,  "can't find application."))
    # get application's dictionary
    appdata = AEBDynamicAppData.alloc().initWithApplicationURL_useSDEF_keywordConverter_(
            url, usesdef, kKeywordConverter)
    terms = appdata.terminologyWithError_(None)
    if not terms:
        raise ValueError("Can't make glue for %r: %s" % (appname,  "can't get terminology."))
    bundle = NSBundle.bundleWithURL_(url)
    bundleid = bundle.infoDictionary()['CFBundleIdentifier'] if bundle else None
    if not bundleid:
        print >> sys.stderr, 'Warning:  +application, -init methods not supported as bundle identifier not found.'
    builder = ClassBuilder(terms, bundleid, noarc)
    builder.render(ImplementationRenderer(appname, prefix, outdir, noarc))
    # export dictionary documentation
    sdef = AEBDynamicSDEFParser.copyScriptingDefinitionAtURL_error_(url, None)
    if not sdef:
        raise ValueError("Can't export SDEF for %r: %s" % (appname,  "can't get terminology."))
    exportsdef(str(sdef), prefix, os.path.join(outdir, os.path.basename(appname.rstrip('/')+'.sdef')))




def makedefaultglue(prefix, outdir, noarc=False):
    """
        prefix : str -- ObjC classname prefix, e.g. 'TE'
        outdir : str -- path to glue folder
        noarc : bool -- if True, use explicit release/autorelease instead of ARC
    """
    appdata = AEBDynamicAppData.alloc().initWithApplicationURL_useSDEF_keywordConverter_(
            None, False, kKeywordConverter)
    terms = appdata.terminologyWithError_(None)
    builder = ClassBuilder(terms, None, noarc)
    builder.render(ImplementationRenderer('<default terminology>', prefix, outdir, noarc))


######################################################################
# MAIN
######################################################################


if __name__ == '__main__':
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'a:p:o:hns')
        opts = dict(opts)
        if not opts or '-h' in opts:
            print >> sys.stderr, "Generate Objective-C application glues for AppleEventBridge"
            print >> sys.stderr
            print >> sys.stderr, "Usage:"
            print >> sys.stderr
            print >> sys.stderr, "    aebglue [-n] [-a NAME] -p PREFIX -o OUTDIR"
            print >> sys.stderr
            print >> sys.stderr, "Options:"
            print >> sys.stderr
            print >> sys.stderr, "    -a NAME    Name or full path to application; if omitted,"
            print >> sys.stderr, "                 use default terminology only"
            print >> sys.stderr, "    -h         Show this help and exit"
            print >> sys.stderr, "    -p PREFIX  Class names prefix"
            print >> sys.stderr, "    -o OUTDIR  Path to output directory"
            print >> sys.stderr, "    -n         Use explicit retain/release, not ARC"
            print >> sys.stderr, "    -s         Use SDEF terminology instead of AETE"
            print >> sys.stderr
            print >> sys.stderr, "Example:"
            print >> sys.stderr
            print >> sys.stderr, "    aebglue -a TextEdit -p TE -o ~/TEGlue"
            print >> sys.stderr
            sys.exit()
        if not ('-o' in opts and '-p' in opts):
            raise TypeError("-o and -p options are required")
        outdir = os.path.abspath(os.path.expanduser(opts['-o']))
        if '-a' in opts:
            makeappglue(opts['-a'], opts['-p'], outdir, '-n' in opts, '-s' in opts)
        else:
            makedefaultglue(opts['-p'], outdir, '-n' in opts)
        print >> sys.stderr, "Written glue to:", outdir
    except Exception, e:
        print >> sys.stderr, "Error:", e
        sys.exit(1)


