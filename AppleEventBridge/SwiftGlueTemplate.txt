//
// «GLUE_NAME»
// «APP_NAME» «APP_VERSION»
// «FRAMEWORK_NAME» «FRAMEWORK_VERSION»
//

import Foundation
import AppleEventBridge

// TO DO: decide if generic specifier roots should appear as app/con/its static vars on XXSymbol class, or as XXApp/XXCon/XXIts vars on module


class «PREFIX»Formatter: SwiftAEFormatter { // used internally to generate description strings

    override var prefix: String {return "«PREFIX»"}
    override var appClassName: String {return "«APP_CLASS_NAME»"}
    
    override func propertyByCode(code: OSType) -> String? {
        switch code {
«+PROPERTY_FORMATTER»
        case «CODE»: return "«NAME»"
«-PROPERTY_FORMATTER»
        default: return super.propertyByCode(code)
        }
    }
    override func elementsByCode(code: OSType) -> String? {
        switch (code) {
«+ELEMENTS_FORMATTER»
        case «CODE»: return "«NAME»"
«-ELEMENTS_FORMATTER»
        default: return super.elementsByCode(code)
        }
    }
}


class «PREFIX»Specifier: SwiftAESpecifier {
        
    override var description: String { return «PREFIX»Formatter.formatObject(aemQuery, appData: aebAppData) }
    
    // Raw property and element specifiers, e.g. TextEdit.elementsByFourCharCode("docu") => TextEdit.documents
    
    func propertyByCode(code: OSType) -> «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemObjectSpecifer("specify a property")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.property(code), queryError: queryError)
    }
    func elementsByCode(code: OSType) -> «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemObjectSpecifer("specify elements")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.elements(code), queryError: queryError)
    }
    func propertyByFourCharCode(code: String) -> «PREFIX»Specifier {
        return self.propertyByCode(AEM4CC(code))
    }
    func elementsByFourCharCode(code: String) -> «PREFIX»Specifier {
        return self.elementsByCode(AEM4CC(code))
    }
    
    // Element(s) selectors
    // important: by-index selectors use Apple event-style 1-indexing, NOT Swift-style 0-indexing

    subscript(index: AnyObject!) -> «PREFIX»Specifier! { // by-index, by-name, by-test

        var baseQuery: AEMMultipleElementsSpecifier?, newQuery: AEMQuery?, queryError: NSError?
        switch (index) {
        case is String:
            (baseQuery, queryError) = self.aemElementsSpecifer("select element named \(index)")
            newQuery = baseQuery?.byName(index)
        case is AEMQueryProtocol:
            (baseQuery, queryError) = self.aemElementsSpecifer("select elements where \(index)")
            if let testClause = (index as! AEMQueryProtocol).aemQuery as? AEMTestClause {
                newQuery = baseQuery?.byTest(testClause)
            }
        default:
            (baseQuery, queryError) = self.aemElementsSpecifer("select element \(index)")
            newQuery = baseQuery?.byIndex(index)
        }
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: newQuery, queryError: queryError)
    }
    func ID(uid: AnyObject) -> «PREFIX»Specifier { // by-id
        let (baseQuery, queryError) = self.aemElementsSpecifer("select element with id \(uid)")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.byID(uid), queryError: queryError)
    }
    subscript(from: AnyObject!, to: AnyObject!) -> «PREFIX»Specifier! { // by-range
        let (baseQuery, queryError) = self.aemElementsSpecifer("select elements \(from) thru \(to)")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.byRange(from, to: to), queryError: queryError)
    }

    func previous(class_: AEBSymbol) -> «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemObjectSpecifer("select previous element")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.previous(class_.aebCode), queryError: queryError)
    }
    func next(class_: AEBSymbol) -> «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemObjectSpecifer("select next element")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.next(class_.aebCode), queryError: queryError)
    }
    
    var first: «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemElementsSpecifer("select first element")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.first(), queryError: queryError)
    }
    var middle: «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemElementsSpecifer("select middle element")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.middle(), queryError: queryError)
    }
    var last: «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemElementsSpecifer("select last element")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.last(), queryError: queryError)
    }
    var any: «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemElementsSpecifer("select any element")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.any(), queryError: queryError)
    }

    func beginning() -> «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemObjectSpecifer("select beginning")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.beginning(), queryError: queryError)
    }
    func end() -> «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemObjectSpecifer("select end")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.end(), queryError: queryError)
    }
    func before() -> «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemObjectSpecifer("select before")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.before(), queryError: queryError)
    }
    func after() -> «PREFIX»Specifier {
        let (baseQuery, queryError) = self.aemObjectSpecifer("select after")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.after(), queryError: queryError)
    }

    // Test clause constructors, e.g. «PREFIX».its.name.beginsWith("foo")
    
    func beginsWith(input: AnyObject!) -> «PREFIX»Specifier! {
        let (baseQuery, queryError) = self.aemObjectSpecifer("test")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.beginsWith(input), queryError: queryError)
    }
    func endsWith(input: AnyObject!) -> «PREFIX»Specifier! {
        let (baseQuery, queryError) = self.aemObjectSpecifer("test")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.endsWith(input), queryError: queryError)
    }
    func contains(input: AnyObject!) -> «PREFIX»Specifier! {
        let (baseQuery, queryError) = self.aemObjectSpecifer("test")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.contains(input), queryError: queryError)
    }
    func isIn(input: AnyObject!) -> «PREFIX»Specifier! {
        let (baseQuery, queryError) = self.aemObjectSpecifer("test")
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery?.isIn(input), queryError: queryError)
    }
    
    // Properties
    
«+PROPERTY_SPECIFIER»
    var «NAME»: «PREFIX»Specifier {return self.propertyByCode(«CODE»)}
«-PROPERTY_SPECIFIER»
    
    // Elements
    
«+ELEMENTS_SPECIFIER»
    var «NAME»: «PREFIX»Specifier {return self.elementsByCode(«CODE»)}
«-ELEMENTS_SPECIFIER»
    
    // Commands
    
«+COMMAND»
    func «COMMAND_NAME»(directParameter: AnyObject = kAEBNoParameter,
«+PARAMETER»
            «NAME»: AnyObject = kAEBNoParameter,
«-PARAMETER»
            returnType: AEBReturnType? = nil, waitReply: Bool? = true, withTimeout: NSTimeInterval? = nil,
            considering: AEBConsiderIgnoreType? = nil, ignoring: AEBConsiderIgnoreType? = nil) throws -> AnyObject! {
        return try self.sendAppleEvent(«EVENT_CLASS», eventID: «EVENT_ID», parameters: [
«+PARAMETER»
                SwiftAEParameter(name: "«NAME»", code: «CODE», value: «NAME»),
«-PARAMETER»
                SwiftAEParameter(name: nil, code: 0x2d2d2d2d, value: directParameter)],
            returnType: returnType, waitReply: waitReply, withTimeout: withTimeout, considering: considering, ignoring: ignoring)
    }
«-COMMAND»
}


class «APP_CLASS_NAME»: «PREFIX»Specifier {
    private init(targetType: AEBTargetType, targetData: AnyObject?) {
        let data = SwiftAEAppData(applicationClass: AEMApplication.self,
                                       symbolClass: «PREFIX»Symbol.self,
                                    specifierClass: «PREFIX»Specifier.self,
                                        targetType: targetType,
                                        targetData: targetData)
        super.init(appData: data, aemQuery: AppleEventBridge.AEMQuery.app())
    }
    override convenience init() { // TO DO: delete/raise error if bundle id not given
        self.init(bundleIdentifier: "«BUNDLE_ID»")
    }
    convenience init(name: NSString) {
        self.init(targetType: kAEBTargetName, targetData: name)
    }
    convenience init(url: NSURL) {
        self.init(targetType: kAEBTargetURL, targetData: url)
    }
    convenience init(bundleIdentifier: NSString) {
        self.init(targetType: kAEBTargetBundleID, targetData: bundleIdentifier)
    }
    convenience init(processIdentifier: Int) {
        self.init(targetType: kAEBTargetProcessID, targetData: processIdentifier)
    }
    convenience init(descriptor: NSAppleEventDescriptor) {
        self.init(targetType: kAEBTargetDescriptor, targetData: descriptor)
    }
    class func currentApplication() -> «APP_CLASS_NAME» {
        return «APP_CLASS_NAME»(targetType: kAEBTargetCurrent, targetData: nil)
    }
    
    // Construct a «PREFIX»Specifier using a raw AEMQuery or other custom object
    // (e.g. if app's terminology is broken or when dealing with especially cranky old apps)
    
    func customRoot(object: AnyObject!) -> «PREFIX»Specifier {
        if object is «PREFIX»Specifier {
            return «PREFIX»Specifier(appData: aebAppData, aemQuery: (object as! «PREFIX»Specifier).aemQuery)
        } else if object is AppleEventBridge.AEMQuery {
            return «PREFIX»Specifier(appData: aebAppData, aemQuery: object as! AppleEventBridge.AEMQuery)
        } else if object == nil {
            return «PREFIX»Specifier(appData: aebAppData, aemQuery: AppleEventBridge.AEMQuery.app())
        } else {
            return «PREFIX»Specifier(appData: aebAppData, aemQuery: AppleEventBridge.AEMQuery.customRoot(object))
        }
    }
}


// test clause constructors, e.g. «PREFIX».its.name != "foo"
// note: the == operator will return a «PREFIX»Specifier when used in elements[...] specifier; however, when
// binding its result to a variable, it must be explicitly typed as (e.g.) AnyObject or Swift will infer Bool

func == (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let (baseQuery, queryError) = left.aemObjectSpecifer("test")
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery?.equals(right), queryError: queryError)
}
func != (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let (baseQuery, queryError) = left.aemObjectSpecifer("test")
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery?.notEquals(right), queryError: queryError)
}
func < (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let (baseQuery, queryError) = left.aemObjectSpecifer("test")
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery?.lessThan(right), queryError: queryError)
}
func > (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let (baseQuery, queryError) = left.aemObjectSpecifer("test")
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery?.greaterThan(right), queryError: queryError)
}
func <= (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let (baseQuery, queryError) = left.aemObjectSpecifer("test")
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery?.lessOrEquals(right), queryError: queryError)
}
func >= (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let (baseQuery, queryError) = left.aemObjectSpecifer("test")
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery?.greaterOrEquals(right), queryError: queryError)
}
func && (left: «PREFIX»Specifier!, right: «PREFIX»Specifier!) -> «PREFIX»Specifier! {
    let (baseQuery, queryError) = left.aemTestClause("test")
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery?.AND(right), queryError: queryError)
}
func || (left: «PREFIX»Specifier!, right: «PREFIX»Specifier!) -> «PREFIX»Specifier! {
    let (baseQuery, queryError) = left.aemTestClause("test")
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery?.OR(right), queryError: queryError)
}
prefix func ! (input: «PREFIX»Specifier!) -> «PREFIX»Specifier! {
    let (baseQuery, queryError) = input.aemTestClause("test")
    return «PREFIX»Specifier(appData: input.aebAppData, aemQuery: baseQuery?.NOT(), queryError: queryError)
}


/******************************************************************************/
// SYMBOLS


class «PREFIX»Symbol: SwiftAESymbol {

    override var description: String {return "«PREFIX».\(self.aebName)"}

    // Generic specifier roots. These can be used to construct «PREFIX»Specifiers for use in other
    // «PREFIX»Specifiers and «PREFIX»Commands, though only real specifiers constructed from a
    // «APP_CLASS_NAME» application instance can be used to send commands to the target application.

    // TO DO: where best to put these root vars?

    static let app = «PREFIX»Specifier(appData: nil, aemQuery: AEMQuery.app())
    static let con = «PREFIX»Specifier(appData: nil, aemQuery: AEMQuery.con())
    static let its = «PREFIX»Specifier(appData: nil, aemQuery: AEMQuery.its())

    override class func symbol(code: OSType) -> AEBSymbol {
        switch (code) {
«+SYMBOL_SWITCH»
        case «CODE»: return self.«NAME»
«-SYMBOL_SWITCH»
        default: return super.symbol(code)
        }
    }

    // Types/properties    // TO DO: add 'override' if var is already defined in AEBSymbol
«+TYPE_SYMBOL»
    static var «NAME»: «PREFIX»Symbol {return «PREFIX»Symbol(name: "«NAME»", type: 0x74797065, code: «CODE»)}
«-TYPE_SYMBOL»

    // Enumerators    // TO DO: add 'override' if var is already defined in AEBSymbol
«+ENUM_SYMBOL»
    static var «NAME»: «PREFIX»Symbol {return «PREFIX»Symbol(name: "«NAME»", type: 0x656e756d, code: «CODE»)}
«-ENUM_SYMBOL»
}


/******************************************************************************/
// TOP-LEVEL CONSTANTS

// Namespace for generic specifiers and symbols, e.g. «PREFIX».app.name, «PREFIX».unicodeText
let «PREFIX» = «PREFIX»Symbol.self


