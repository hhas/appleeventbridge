//
// «GLUE_NAME»
// «APP_NAME» «APP_VERSION»
// «FRAMEWORK_NAME» «FRAMEWORK_VERSION»
//

import Foundation
import AppleEventBridge

// TO DO: decide if generic specifier roots should appear as app/con/its static vars on XXSymbol class, or as XXApp/XXCon/XXIts vars on module


class «PREFIX»Formatter: SwiftAEFormatter { // used internally to generate description strings
    
    override var prefix: String {return "«PREFIX»"}
    
    override func propertyByCode(code: OSType) -> String? {
        switch code {
«+PROPERTY_FORMATTER»
        case «CODE»: return "«NAME»"
«-PROPERTY_FORMATTER»
        default: return super.propertyByCode(code)
        }
    }
    override func elementsByCode(code: OSType) -> String? {
        switch (code) {
«+ELEMENTS_FORMATTER»
        case «CODE»: return "«NAME»"
«-ELEMENTS_FORMATTER»
        default: return super.elementsByCode(code)
        }
    }
}


class «PREFIX»Specifier: SwiftAESpecifier {
        
    override var description: String { return «PREFIX»Formatter.formatObject(aemQuery, appData: aebAppData) }
    
    // Raw property and element specifiers, e.g. TextEdit.elementsByFourCharCode("docu") => TextEdit.documents
    
    func propertyByCode(code: OSType) -> «PREFIX»Specifier {
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: (aemQuery as! AEMObjectSpecifier).property(code))
    }
    func elementsByCode(code: OSType) -> «PREFIX»Specifier {
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: (aemQuery as! AEMObjectSpecifier).elements(code))
    }
    func propertyByFourCharCode(code: String) -> «PREFIX»Specifier {
        return self.propertyByCode(AEM4CC(code))
    }
    func elementsByFourCharCode(code: String) -> «PREFIX»Specifier {
        return self.elementsByCode(AEM4CC(code))
    }
    
    // Element(s) selectors
    // important: by-index selectors use Apple event-style 1-indexing, NOT Swift-style 0-indexing

    subscript(index: AnyObject!) -> «PREFIX»Specifier! { // by-index, by-name, by-test
        let baseQuery = self.aemQuery as! AEMMultipleElementsSpecifier
        switch (index) {
        case is String:
            return «PREFIX»Specifier(appData: aebAppData, aemQuery:  baseQuery.byName(index))
        case is «PREFIX»Specifier:
            let testClause = (index is AEBSpecifier ? (index as! AEBSpecifier).aemQuery : aemQuery) as! AEMTestClause
            return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.byTest(testClause))
        default:
            return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.byIndex(index))
        }
    }
    func ID(uid: AnyObject) -> «PREFIX»Specifier { // by-id
        let baseQuery = self.aemQuery as! AEMMultipleElementsSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.byID(uid))
    }
    subscript(from: AnyObject!, to: AnyObject!) -> «PREFIX»Specifier! { // by-range
        let newQuery = (self.aemQuery as! AEMMultipleElementsSpecifier).byRange(from, to: to)
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: newQuery)
    }
    
    func previous(class_: AEBSymbol) -> «PREFIX»Specifier {
        let baseQuery = self.aemQuery as! AEMMultipleElementsSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.previous(class_.aebCode))
    }
    func next(class_: AEBSymbol) -> «PREFIX»Specifier {
        let baseQuery = self.aemQuery as! AEMMultipleElementsSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.next(class_.aebCode))
    }
    
    var first:  «PREFIX»Specifier {return «PREFIX»Specifier(appData: aebAppData, aemQuery: (self.aemQuery as! AEMMultipleElementsSpecifier).first())}
    var middle: «PREFIX»Specifier {return «PREFIX»Specifier(appData: aebAppData, aemQuery: (self.aemQuery as! AEMMultipleElementsSpecifier).middle())}
    var last:   «PREFIX»Specifier {return «PREFIX»Specifier(appData: aebAppData, aemQuery: (self.aemQuery as! AEMMultipleElementsSpecifier).last())}
    var any:    «PREFIX»Specifier {return «PREFIX»Specifier(appData: aebAppData, aemQuery: (self.aemQuery as! AEMMultipleElementsSpecifier).any())}
    
    func beginning() -> «PREFIX»Specifier {
        let baseQuery = self.aemQuery as! AEMMultipleElementsSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.beginning())
    }
    func end() -> «PREFIX»Specifier {
        let baseQuery = self.aemQuery as! AEMMultipleElementsSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.end())
    }
    func before() -> «PREFIX»Specifier {
        let baseQuery = self.aemQuery as! AEMMultipleElementsSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.before())
    }
    func after() -> «PREFIX»Specifier {
        let baseQuery = self.aemQuery as! AEMMultipleElementsSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.after())
    }

    // Test clause constructors, e.g. «PREFIX».its.name.beginsWith("foo")
    
    func beginsWith(input: AnyObject!) -> «PREFIX»Specifier! {
        let baseQuery = self.aemQuery as! AEMObjectSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.beginsWith(input))
    }
    func endsWith(input: AnyObject!) -> «PREFIX»Specifier! {
        let baseQuery = self.aemQuery as! AEMObjectSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.endsWith(input))
    }
    func contains(input: AnyObject!) -> «PREFIX»Specifier! {
        let baseQuery = self.aemQuery as! AEMObjectSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.contains(input))
    }
    func isIn(input: AnyObject!) -> «PREFIX»Specifier! {
        let baseQuery = self.aemQuery as! AEMObjectSpecifier
        return «PREFIX»Specifier(appData: aebAppData, aemQuery: baseQuery.isIn(input))
    }
    
    // Properties
    
«+PROPERTY_SPECIFIER»
    var «NAME»: «PREFIX»Specifier {return self.propertyByCode(«CODE»)}
«-PROPERTY_SPECIFIER»
    
    // Elements
    
«+ELEMENTS_SPECIFIER»
    var «NAME»: «PREFIX»Specifier {return self.elementsByCode(«CODE»)}
«-ELEMENTS_SPECIFIER»
    
    // Commands
    
«+COMMAND»
    func «COMMAND_NAME»(directParameter: AnyObject = kAEBNoParameter,
«+PARAMETER»
            «NAME»: AnyObject = kAEBNoParameter,
«-PARAMETER»
            returnType: AEBReturnType? = nil, waitReply: Bool? = true, withTimeout: NSTimeInterval? = nil,
            considering: AEBConsiderIgnoreType? = nil, ignoring: AEBConsiderIgnoreType? = nil) throws -> AnyObject! {
        return try self.sendAppleEvent(«EVENT_CLASS», eventID: «EVENT_ID», parameters: [
«+PARAMETER»
                SwiftAEParameter(name: "«NAME»", code: «CODE», value: «NAME»),
«-PARAMETER»
                SwiftAEParameter(name: nil, code: 0x2d2d2d2d, value: directParameter)],
            returnType: returnType, waitReply: waitReply, withTimeout: withTimeout, considering: considering, ignoring: ignoring)
    }
«-COMMAND»
}


class «PREFIX»Application: «PREFIX»Specifier {
    private init(targetType: AEBTargetType, targetData: AnyObject?) {
        let data = SwiftAEAppData(applicationClass: AEMApplication.self,
                                       symbolClass: «PREFIX»Symbol.self,
                                    specifierClass: «PREFIX»Specifier.self,
                                        targetType: targetType,
                                        targetData: targetData)
        super.init(appData: data, aemQuery: AppleEventBridge.AEMQuery.app())
    }
    override convenience init() { // TO DO: delete/raise error if bundle id not given
        self.init(bundleIdentifier: "«BUNDLE_ID»")
    }
    convenience init(name: NSString) {
        self.init(targetType: kAEBTargetName, targetData: name)
    }
    convenience init(url: NSURL) {
        self.init(targetType: kAEBTargetURL, targetData: url)
    }
    convenience init(bundleIdentifier: NSString) {
        self.init(targetType: kAEBTargetBundleID, targetData: bundleIdentifier)
    }
    convenience init(processIdentifier: Int) {
        self.init(targetType: kAEBTargetProcessID, targetData: processIdentifier)
    }
    convenience init(descriptor: NSAppleEventDescriptor) {
        self.init(targetType: kAEBTargetDescriptor, targetData: descriptor)
    }
    class func currentApplication() -> «PREFIX»Application {
        return self.init(targetType: kAEBTargetCurrent, targetData: nil)
    }
    
    // Construct a «PREFIX»Specifier using a raw AEMQuery or other custom object
    // (e.g. if app's terminology is broken or when dealing with especially cranky old apps)
    
    func customRoot(object: AnyObject!) -> «PREFIX»Specifier {
        if object is «PREFIX»Specifier {
            return «PREFIX»Specifier(appData: aebAppData, aemQuery: (object as! «PREFIX»Specifier).aemQuery)
        } else if object is AppleEventBridge.AEMQuery {
            return «PREFIX»Specifier(appData: aebAppData, aemQuery: object as! AppleEventBridge.AEMQuery)
        } else if object == nil {
            return «PREFIX»Specifier(appData: aebAppData, aemQuery: AppleEventBridge.AEMQuery.app())
        } else {
            return «PREFIX»Specifier(appData: aebAppData, aemQuery: AppleEventBridge.AEMQuery.customRoot(object))
        }
    }
}


// test clause constructors, e.g. «PREFIX».its.name != "foo"
// note: the == operator will return a «PREFIX»Specifier when used in elements[...] specifier; however, when
// binding its result to a variable, it must be explicitly typed as (e.g.) AnyObject or Swift will infer Bool

func == (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let baseQuery = left.aemQuery as! AEMObjectSpecifier
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery.equals(right))
}
func != (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let baseQuery = left.aemQuery as! AEMObjectSpecifier
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery.notEquals(right))
}
func < (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let baseQuery = left.aemQuery as! AEMObjectSpecifier
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery.lessThan(right))
}
func > (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let baseQuery = left.aemQuery as! AEMObjectSpecifier
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery.greaterThan(right))
}
func <= (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let baseQuery = left.aemQuery as! AEMObjectSpecifier
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery.lessOrEquals(right))
}
func >= (left: «PREFIX»Specifier!, right: AnyObject!) -> «PREFIX»Specifier! {
    let baseQuery = left.aemQuery as! AEMObjectSpecifier
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery.greaterOrEquals(right))
}
func && (left: «PREFIX»Specifier!, right: «PREFIX»Specifier!) -> «PREFIX»Specifier! {
    let baseQuery = left.aemQuery as! AEMTestClause
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery.AND(right))
}
func || (left: «PREFIX»Specifier!, right: «PREFIX»Specifier!) -> «PREFIX»Specifier! {
    let baseQuery = left.aemQuery as! AEMTestClause
    return «PREFIX»Specifier(appData: left.aebAppData, aemQuery: baseQuery.OR(right))
}
prefix func ! (input: «PREFIX»Specifier!) -> «PREFIX»Specifier! {
    let baseQuery = input.aemQuery as! AEMTestClause
    return «PREFIX»Specifier(appData: input.aebAppData, aemQuery: baseQuery.NOT())
}


/******************************************************************************/
// SYMBOLS


class «PREFIX»Symbol: SwiftAESymbol {

    override var description: String {return "«PREFIX».\(self.aebName)"}

    // Generic specifier roots. These can be used to construct «PREFIX»Specifiers for use in other
    // «PREFIX»Specifiers and «PREFIX»Commands, though only real specifiers constructed from a
    // «PREFIX»Application can be used to send commands to the target application.

    static let app = «PREFIX»Specifier(appData: nil, aemQuery: AEMQuery.app())
    static let con = «PREFIX»Specifier(appData: nil, aemQuery: AEMQuery.con())
    static let its = «PREFIX»Specifier(appData: nil, aemQuery: AEMQuery.its())

    override class func symbol(code: OSType) -> AEBSymbol {
        switch (code) {
«+SYMBOL_SWITCH»
        case «CODE»: return self.«NAME»
«-SYMBOL_SWITCH»
        default: return super.symbol(code)
        }
    }

    // Types/properties    // TO DO: add 'override' if var is already defined in AEBSymbol
«+TYPE_SYMBOL»
    static var «NAME»: «PREFIX»Symbol {return «PREFIX»Symbol(name: "«NAME»", type: 0x74797065, code: «CODE»)}
«-TYPE_SYMBOL»

    // Enumerators    // TO DO: add 'override' if var is already defined in AEBSymbol
«+ENUM_SYMBOL»
    static var «NAME»: «PREFIX»Symbol {return «PREFIX»Symbol(name: "«NAME»", type: 0x656e756d, code: «CODE»)}
«-ENUM_SYMBOL»
}


/******************************************************************************/
// TOP-LEVEL CONSTANTS

// Namespace for generic specifiers and symbols, e.g. «PREFIX».app.name, «PREFIX».unicodeText
let «PREFIX» = «PREFIX»Symbol.self

// Convenience constructor for application objects, e.g. «APP_VAR_NAME».activate()
var «APP_VAR_NAME»: «PREFIX»Application {return «PREFIX»Application()}

